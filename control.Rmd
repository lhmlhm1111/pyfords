---
title: "데이터 과학을 위한 파이썬"
subtitle: "02.제어문, 클래스, 패키지"
author: "Jeonghyun Gan, DataScience Lab"
output: 
  rmdformats::readthedown:
    css: "assets/css/typo.css"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Intro

이번 장에서는 프로그램의 흐름을 제어하는 제어문들, 그리고 객체 지향 프로그래밍과 클래스에 대해 공부합니다. 직선적인 프로그램으로 데이터를 다루는 데에는 한계가 있습니다. 데이터에 같은 작업을 반복하거나 조건에 따라 다른 작업을 해야할 때, 제어문을 적절히 사용해서 효율적인 코드를 짤 수 있습니다. 이번 장에서는 크게 반복문, 조건문와 예외 통제 구문들을 다룹니다. 객체 지향 프로그래밍은 파이썬의 가장 큰 특징 중의 하나이며, 클래스는 객체 지향 프로그램의 중심을 이루는 개념입니다. 단번에 이해하지 못하더라도 꾸준히 복습하면서 클래스와 객체의 개념에 익숙해지시기 바랍니다.

# 1. 조건문

조건문은 프로그래밍 흐름에서 가지를 치는 역할을 합니다. 즉 주어진 조건을 판단하여 상황마다 다른 코드가 실행되도록 만드는 것이 조건문의 역할입니다. 파이썬의 조건문은 if, else, elif 의 세 가지 구문으로 이루어집니다. 이 구문들을 차례대로 살펴보겠습니다.

## 1.1. if

```{python eval=F}
if 조건:
   조건이 True일 때 실행할 코드 # 들여쓰기 필수!!
```

**if 문은 조건과 함께 사용하며, 주어진 조건이 True일 때 이하의 코드를 실행합니다. 조건은 True/False로 진리값을 명확하게 판단할 수 있는 연산이어야 합니다.** if 문의 기본적인 구조는 위와 같습니다. if 다음 조건을 걸고 콜론을 적은 후, 다음 줄부터 조건이 참일 때 실행할 코드를 적어주면 됩니다.

```{python eval=F}
>>> score = 90
>>> if score >= 60:
...     print("Pass")
Pass
```

위는 if 문의 간단한 예시입니다. 첫 줄에서는 score 변수에 90을 할당합니다. if 문에서 score >= 60을 판단하고, 만약 참이라면 "Pass"를 프린트합니다. 90 >= 60 이므로 "Pass" 를 프린트합니다.

## 1.2. else

```{python eval=F}
if 조건:
   조건이 참일 때 실행할 코드 # 들여쓰기 필수!!
else:
   조건이 거짓일 때 실행할 코드 # 들여쓰기 필수!!
```

if 의 짝은 else입니다. 조건이 참일 때만 조작이 필요하다면, if 문만 사용해도 충분합니다. 하지만 조건이 거짓일 때도 그에 맞는 조작이 필요하다면, else 문을 함께 사용합니다. **if 문 이하의 코드는 조건이 참일 때 실행되고, else 문 이하의 코드는 조건이 거짓일 때 실행됩니다. else 문 다음에는 조건을 붙이지 않습니다!**

```{python eval=F}
>>> def pnp(score):
...     if score >= 60:
...         return("Pass")
...     else: # score < 60
...         return("Non-Pass")
>>> pnp(60)
'Pass'
>>> pnp(40)
'Non-Pass'
```

위의 코드에서는 조건문을 함수 안으로 집어넣었습니다. pnp는 score라는 인자를 받는 함수이며, score가 60보다 크거나 같으면 "Pass"를 반환하고, 그렇지 않으면 "Non-Pass"를 반환합니다. pnp(60)을 실행하면 함수는 60 >= 60을 판단합니다. 이 결과가 참이므로 if 절 이하의 코드인 return("Pass")가 실행됩니다. pnp(50) 실행하면 함수는 50 >= 60을 판단합니다. 이 결과가 거짓이므로 프로그램은 if 문 이하의 코드를 건너뛰고, else 절로 넘어갑니다. 따라서 return("Non-Pass")가 실행됩니다.

## 1.3. elif

```{python eval=F}
if 조건 1:
    조건 1이 True일 때 실행할 코드
elif 조건 2:
    조건 1이 False 이고 조건 2가 True일 때 실행할 코드
elif 조건 3:
    조건 1, 조건 2가 False 이고 조건 3가 True일 때 실행할 코드
.
.
.
else:
    모든 조건들이 False일 때 실행할 코드
    
```

패스와 논패스의 이진 분류를 수행하는 프로그램에는 if 와 else 면 충분합니다. 하지만 학생에게 A부터 F까지의 성적을 매기려면 if 와 else 만으로는 힘듭니다. 먼저 학생의 성적이 F인지 아닌지를 판단하고, F가 아닌 경우 D인지 아닌지 판단하고 ... 이러한 과정을 A까지 반복해야 합니다. **elif 를 사용하면 이런 다중 분기를 손쉽게 구현할 수 있습니다.** if - elif - else 문의 구조는 위와 같습니다. if 문부터 순차적으로 조건을 판단하고, 거짓이면 다음 elif로 넘어가는 방식입니다.

```{python eval=F}
>>> def grade(score):
...     if score >= 90:
...         return("A")
...     elif score >= 80: # score >= 90 이 거짓: score >= 80 & score < 90
...         return("B")
...     elif score >= 70: # score >= 80 이 거짓: score >= 70 & score < 80
...         return("C")
...     elif score >= 60: # score >= 70 이 거짓: score >= 60 & score < 70
...         return("D")
...     else: # score >= 60 이 거짓: score < 60
...         return("F")
...
>>> grade(90)
'A'
>>> grade(80)
'B'
>>> grade(70)
'C'
>>> grade(60)
'D'
>>> grade(50)
'F'
>>>   
```

위의 코드는 점수에 따라 학점을 매기는 함수를 구현한 예시입니다. 가장 먼저 90점 이상인지를 판단하고, 이 결과가 거짓이면 다음 elif 로 넘어가서 80점 이상인지를 판단합니다. 이러한 과정을 60점까지 반복하고 나머지 경우에는 F를 반환합니다.

**예제 1.1. 주어진 파일 이름 문자열의 확장자가 .csv, .json, .xlsx 중 하나이면 True 아니면 False 를 반환하는 함수를 작성하세요. 이후 이 함수를 filelist 에 매핑하세요.**

```{python eval=F}
>>> filelist = ["data.csv", "자기소개서.hwp", "졸업학점계산기.xlsx", "기말보고서.docx", "apikey.json"]
>>> result = your_code ...
>>> print(result)
[True, False, True, False, True]
```

**풀이**

1. 파일의 확장자를 판단하는 함수를 작성합니다.

    - 먼저 파일 이름에서 확장자를 분리해내야 합니다. 확장자는 파일 이름의 가장 마지막에 .확장자 형식으로 붙습니다. 따라서 파일 이름을 "."을 기준으로 스플릿해준 후에, 결과로 나온 리스트의 마지막 요소를 인덱싱하면 확장자를 추출할 수 있습니다. 

    - 확장자를 분리해냈으면 이 확장자가 csv, xlsx, json 중 하나에 속하는지 판단하면 됩니다. if - elif - else 를 사용할 수도 있지만, in 연산을 사용해서 한번에 처리할 수도 있습니다. 확장자가 ["csv","xlsx", "json"] 중 하나에 속하면 True, 아니면 False를 반환합니다.
    
2. 만든 함수를 리스트에 매핑합니다.

```{python eval=F}
>>> filelist = ["data.csv", "자기소개서.hwp", "졸업학점계산기.xlsx", "기말보고서.docx", "apikey.json"]
>>> def my_funcion(filename):
...     if filename.split(".")[-1] in ["csv","xlsx","json"]:
...         return True
...     else:
...         return False
>>> result = list(map(my_function,filelist))
>>> print(result)
[True, False, True, False, True]
```

# 2. 반복문

## 2.1. for in 반복문

### for in 반복문의 구조

for in 반복문은 파이썬에서 가장 흔하게 사용되는 반복문이며, **리스트처럼 일정한 순서와 길이를 갖는 객체의 요소들에 같은 작업을 반복적으로 적용합니다.** 아래 예시 코드를 보겠습니다.

```{python eval=F}
>>> for 변수 in 리스트/튜플/...:
...    작업 코드 # 들여쓰기 필수!
>>> for i in [1,2,3]:
...     print(i)
1
2
3
```

for i in [1,2,3]에서 i는 변수이고, [1,2,3] 은 1, 2, 3을 요소로 갖는 리스트입니다. **반복문 for i in [1,2,3] 에서는 변수 i에 리스트 [1,2,3]의 요소들인 1, 2, 3을 순차적으로 할당하게 됩니다.** 즉 루프의 첫 번째 바퀴에서는 i=1 이 되고, 따라서 print(i)의 결과로 1이 출력됩니다. 루프의 두 번째, 세 번째 바퀴에서는 각각 i=2, i=3이 되고, 따라서 print(i)의 결과로 3이 출력됩니다. def 문으로 함수를 만들 때와 마찬가지로, 콜론 이후의 절에서는 반드시 들여쓰기를 해주어야 합니다. 반복문을 사용하지 않고 코드를 풀어보면 다음과 같습니다.

```{python eval=F}
>>> i = 1
>>> print(i)
1
>>> i = 2
>>> print(i)
2
>>> i = 3
>>> print(i)
3
>>>   
```

**예제 2.1. 다음 코드를 반복문으로 구현해보세요**

```{python eval=F}
>>> number = 100
>>> print(number < 200)
True
>>> number = 200
>>> print(number < 200)
False
>>> number = 300
>>> print(number < 200)
False
```

**풀이**

위 코드에서는 number 변수에 100, 200, 300을 할당하면서 number < 200 연산을 동일하게 수행하고 있습니다. 따라서 100, 200, 300 을 리스트로 만들고 for 문을 적용하면 문제를 해결할 수 있습니다.

```{python eval=F}
>>> for number in [100, 200, 300]:
...    print(number < 200)
True
False
False
```

### for i in range(n)

for in 반복문은 range(a,b) 함수와 함께 사용되는 경우가 많습니다. range(a,b) 함수는 a부터 b까지의 정수 구간을 생성하는 함수이며, b는 구간에 포함되지 않습니다. range(a)와 같이 쓰면 0부터 a까지의 정수 구간을 생성하며, 역시 a는 구간에 포함되지 않습니다.

```{python eval=F}
>>> for i in range(1,3):
...     print(i)
1
2
>>> for i in range(3):
...     print(i)
0
1
2
```

'for 변수 in 리스트' 와 같은 형태의 반복문에서 반드시 지정한 변수를 활용할 필요는 없습니다. 사실 for i in range(n) 과 같은 형태의 반복문은 변수 i와 관계없는 작업을 단순히 n번 반복하기 위해 사용하기도 합니다. 아래 예시 코드를 보겠습니다. for i in range(3) 이라는 코드는 루프마다 i=0, i=1, i=2을 할당합니다. 하지만 실제 반복문 안에서 실행되는 코드는 print("Hello world") 로 i와는 전혀 관계가 없습니다.

```{python eval=F}
>>> for i in range(3):
...     print("Hello world")
Hello world
Hello world
Hello world
```

**예제 2.2. for 반복문과 range 함수를 활용하여 1부터 100까지 자연수의 합을 구하세요**

**풀이**

이번 문제를 풀기 위해서는 약간의 테크닉이 필요합니다. 먼저 반복문 바깥에 result라는 변수를 만들고 0을 할당합니다. 이후 1부터 100까지의 숫자를 차례대로 result 변수에 더해주면, 1부터 100까지 자연수의 합을 구할 수 있습니다. 반복문 외부에 결과를 저장할 변수를 만들고 루프를 돌면서 변수를 업데이트하는 기법은 자주 쓰이므로 기억해두면 좋습니다.

```{python eval=F}
>>> result = 0
>>> for i in range(1,101):
...     result = result + i
>>> print(result)
5050
```

**예제 2.3. for 반복문과 range 함수를 활용하여 1\*\*2, 2\*\*2, 3\*\*2 ... 10000\*\*2을 포함하는 리스트를 만들어보세요.**

**풀이**

최종적으로 만들 결과물이 리스트이기 때문에, 반복문 밖에 빈 리스트를 생성합니다. 이후 range(1,100001) 를 이용해 구간을 생성하고, 루프를 돌면서 i**2 를 리스트에 추가해줍니다. 결과의 출력은 생략하겠습니다.

```{python eval=F}
>>> mylist = []
>>> for i in range(1,100001):
...    mylist.append(i**2)
```

### List Comprehension

위의 예제에서는 빈 리스트에 append 메소드를 반복적하여 리스트를 만들어 보았습니다. 이번에는 List comprehension이라는 방법을 사용하여 리스트를 만들어볼 것입니다. 아래는 지금까지 해왔던 방식으로 0부터 9까지의 숫자를 제곱한 리스트를 만드는 코드입니다.

```{python eval=F}
>>> mylist = []
>>> for i in range(10):
...    mylist.append(i**2)
>>> print(mylist)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

아래는 List comprehension을 활용한 예시 코드입니다. 지금까지 사용한 반복문들과 달리, 이번에는 **for in 구문이 대괄호 [] 안에서 쓰였으며, for 문이 시작하기 전에 이미  i \*\* 2와 같이 변수를 활용한 연산이 나옵니다.** 복잡해보일 수 있는 구조이지만, 콜론 뒤에 나오던 연산 과정이 앞으로 당겨졌을 뿐입니다. List comprehension을 사용하면 append를 사용하는 것보다 코드를 더 간결하게 쓸 수 있고, 일반적으로 실행 시간도 단축됩니다.

```{python eval=F}
>>> [연산 for 변수 in 리스트] # 리스트 컴프리헨션의 구조
>>> mylist = [i**2 for i in range(10)]
>>> print(mylist)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

**예제 2.4. LIst comprehension을 사용하여 구구단 6단 리스트를 만드세요**

```{python eval=F}
[6, 12, 18, 24, 30, 36, 42, 48, 54]
```

**풀이**

구구단은 6\*1, 6\*2, ..., 6\*9 와 같이 진행됩니다. 즉 6 * i를 i=1부터 i=9까지 반복하면 구구단 6단을 만들 수 있습니다. 이 때 연산은 6 *i가 되고, 리스트는 [1,2,...,9]가 될 것입니다. 따라서 다음과 같은 코드를 사용하여 구구단 6단의 리스트를 만들 수 있습니다.

```{python eval=F}
>>> [6 * i for i in range(1,10)]
[6, 12, 18, 24, 30, 36, 42, 48, 54]
```

## 2.2. while 반복문

```{python eval=F}
while 조건:
    조건이 참인 동안 실행할 코드
```

while 반복문은 for in 반복문과 달리, 조건과 함께 사용됩니다. while 이후의 조건이 참인 동안 조건 이후의 코드를 계속해서 수행하게 됩니다.

```{python eval=F}
>>> while True:
...     print("Press Ctrl+C to escape")
...
Press Ctrl+C to escape
Press Ctrl+C to escape
Press Ctrl+C to escape
.
.
.
```

위 예시 코드에서는 조건이 True입니다. 즉 해당 반복문은 사용자가 멈추지 않는 이상 계속해서 반복됩니다. while 반복문은 자주 사용하지는 않지만, 알아둘 필요는 있습니다.

## 2.3. 반복문 안에서의 흐름 제어

반복문 안에 추가적으로 흐름을 제어하는 명령어들을 배치할 수 있습니다. continue 는 즉시 다음 바퀴로 넘어가는 명령어이고, break 는 반복을 멈추는 명령어입니다. 역시 자주 쓰이지는 않지만 알아둘 필요는 없습니다.

명령어|기능
---|---
continue|즉시 다음 바퀴로 넘어감
break|반복 정지, 다음 코드로 넘어감

```{python eval=F}
>>> for i in range(10):
...     if i < 5:
...         continue
...     print(i)
...
5
6
7
8
9
```

```{python eval=F}
>>> for i in range(10):
...     if i == 5:
...         break
...     print(i)
...
1
2
3
4
```

# 3. 객체 지향 프로그래밍과 클래스

파이썬은 대표적인 객체 지향 프로그래밍 언어이며, 객체 지향과 클래스는 파이썬을 배우면서 언젠가는 짚고 넘어가야 하는 부분입니다. 하지만 객체 지향과 클래스가 단번에 이해할 수 있는 개념은 아닙니다. 사실 프로그래밍을 배운다는 것이 모든 스킬을 선형적으로 습득해가는 과정이 절대 아니기 때문에, 지금 이해가 가지 않는다고 해서 조급해할 필요는 없습니다. 또한 지금은 개발을 목적으로 파이썬을 배우는 것아 아니므로 클래스를 꼭 자유자재로 다룰 수 있어야 하는 것도 아닙니다. 만들어진 클래스의 구조를 이해하고 활용할 수 있는 정도면 충분합니다.

## 3.1. 클래스, 객체, 인스턴스

프로그램은 수많은 명령어들로 이루어집니다. 하지만 객체 지향 프로그래밍에서는 명령어가 아닌 객체들이 프로그램의 중심이 됩니다. 객체란 마치 현실 세계에 존재하는 사물들과 유사한 것입니다. **현실 세계의 사물들은 특정한 속성을 갖고, 스스로 행동하거나 다른 사물들에 의해서 조작될 수 있습니다. 예를 들어 사람은 이름과 나이를 속성으로 가질 수 있고, 인사를 하는 등 행동을 할 수 있습니다.** 인사를 할 수 있는 사람을 간단한 파이썬 프로그램으로 구현해보면 다음과 같습니다. 코드 해설을 모두 이해할 필요는 없고, 다만 우리가 현실세계의 사람을 모방해서 사람과 같은 속성을 갖고, 사람처럼 행동하는 무언가를 만들었다는 사실을 주목해주시면 됩니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age): # person 클래스의 속성을 정의
...         self.name = name
...         self.age = age
...     def sayhello(self):
...         print("Hello!")
>>> superson = person(name="손흥민", age=28) # 손흥민을 닮은 객체를 만들어봐요!
>>> superson.name # 속성
'손흥민'
>>> superson.age # 속성
28
>>> superson.sayhello() # 메소드(행동)
Hello!
```

가장 먼저 `class person: ...` 명령어를 사용해서 person 이라는 클래스를 만들었습니다. `superson = person(name="손흥민",age=28)` 은 이름이 "손흥민" 이고 나이가 28 인 사람을 만들어서 superson이라는 변수에 저장한 것입니다. 이제 파이썬 세상에서 superson 은 이름과 나이를 갖는 사람처럼 취급될 수 있습니다. superson.name, supserson.age 를 통해서 superson의 이름과 나이라는 속성에 접근할 수 있고, superson.sayhello() 를 통해서 인사를 하는 행동을 구현할 수도 있습니다.

### 클래스와 객체/인스턴스 구분하기

- 클래스: 객체/인스턴스를 찍어내는 틀이자 객체/인스턴스가 속하는 그룹
- 객체/인스턴스: 클래스에 의해 만들어진 존재, 대상

**클래스는 객체가 속하는 그룹이자 객체를 찍어내는 틀입니다.** person 클래스를 구현해놓으면 서로 다른 속성을 갖는 여러 사람들을 손쉽게 만들어낼 수 있습니다. person 클래스는 가지고 서로 다른 이름과 나이를 갖는 객체들을 만드는 예시입니다. 각자 다른 이름과 나이를 갖기는 하지만, 이들은 모두 person 클래스에 속하는 객체들입니다.

```{python eval=F}
>>> supserson = person(name="손흥민", age=27)
>>> yoonaqueen = person(name="김연아", age=29)
>>> psy = person(name="박재상", age=41)
```

**클래스를 사용해서 만들어낸 실제 대상을 객체 혹은 인스턴스라고 부릅니다.** 객체와 인스턴스는 엄밀하게 구분하기도 하지만, 여기에서는 구분 없이 사용하겠습니다. 위의 예제에서 person 클래스를 사용해서 만든 superson, yoonaqueen, psy 가 모두 인스턴스입니다. 

## 3.2. 클래스 만들기

### class 명령어

이제 본격적으로 클래스를 만드는 방법을 다뤄보겠습니다. 우선 아무것도 없는 빈 클래스를 만들어보겠습니다. 클래스를 만들 때는 class 라는 명령어를 사용합니다. `class 클래스이름` 과 같이 적어주면 클래스를 생성할 수 있습니다. 아무 것도 포함하는 것이 없는 클래스를 만들기 위해 콜론 이후에는 pass 를 적어줍니다. 빈 클래스를 통해서도 인스턴스들을 찍어낼 수 있습니다.

```{python eval=F}
>>> class person:
...     pass
>>> superson = person()
```

### 클래스에 속성 부여하기

하지만 위와 같은 클래스는 아무 속성도 갖지 않고, 아무런 행동도 할 수 없습니다. 이제부터는 속성을 갖고 행동도 할 수 있는 person 클래스를 만들어보도록 하겠습니다. 클래스에 속성을 부여하기 위해서는, 클래스 안에 `__init__` 함수를 정의해야 합니다. **`__init__ ` 함수는 초기화, 혹은 시작을 뜻하며 클래스가 필수적으로 가져야 할 속성들을 정의합니다.** __init__ 함수의 기본적인 구조는 다음과 같습니다.

```{python eval=F}
>>> __init__(self, 속성1, 속성2, ...):
...     self.속성1 = 속성1
...     self.속성2 = 속성2
...     ...
```

**`__init__` 함수는 `self`, `속성` 이라는 두 종류의 매개변수를 갖습니다. self 는 클래스에 의해 생성될 인스턴스를 가리키며, 클래스 안에서 정의되는 모든 함수에 반드시 포함되어야 하는 매개변수입니다.** self 이후의 매개변수들은 자신이 원하는 속성들을 표현할 수 있는 변수 이름들을 나열해주시면 됩니다. 만약 person 클래스에 name과 age라는 속성을 정의하고 싶다면 우선 self, name, age라는 세 가지 매개변수를 갖는 `__init__` 함수를 class 안에 정의해야 합니다. 즉 우선 다음과 같이 써야 합니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age):
```

이제 `__init__` 함수의 내부를 살펴볼 차례입니다. `__init__` 함수의 내부 구조는 간단하지만, 처음 보면 당황스러울 수 있습니다. 자신이 정의하려는 속성들을 `self.속성 = 속성`과 같이 차례로 할당해주면 됩니다. self 는 클래스에 의해 생성될 인스턴스라고 언급하였습니다. 따라서 self.name 코드는 새로 만들 인스턴스의 name 속성에 name 값을 할당하며, self.age 코드는 새로 만들 인스턴스의 age 속성에 age 값을 할당합니다. name 값과 age 값은 사용자가 인스턴스를 생성할 때 지정하기 때문에, 실제로 인스턴스를 생성하는 코드를 함께 봐야 이해하기 쉽습니다. 예를 들어 지금까지 만든 person 클래스로 superson이라는 인스턴스를 만든다면, person 클래스와 `__init__` 함수 내부에서는 다음과 같은 일이 발생할 것입니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age):
...         self.name = name # 인스턴스의 name 속성 = name 에 들어있는 값
...         self.age = age # 인스턴스의 age 속성 = age 에 들어있는 값
>>> superson = person(name="손흥민", age=28) 

##################### __init__ 함수 내부에서의 작용 ###########################
__init__(self=superson, name="손흥민", age=28):
    superson.name = "손흥민" # superson.name 에는 "손흥민" 할당
    superson.age = 28 # superson.age 에는 28 할당
###############################################################################

>>> superson.name
'손흥민'
>>> supserson.age
28
```

### 클래스에 메소드 부여하기

일정한 속성을 갖는 클래스를 생성했다면 이제는 메소드, 즉 행동을 정의해볼 차례입니다. 메소드는 역시 class 안에 함수로 정의하며, 자신이 원하는 이름으로 함수를 만들어주면 됩니다. 반드시 self를 매개변수로 갖는다는 점이 일반적인 함수와 다릅니다.

```{python eval=F}
>>> def 메소드명(self, 인자1, 인자2, ...):
>>>    연산
>>>    return 결과물
```

간단하게 매개변수 없이 "Hello" 를 프린트하는 sayhello 메소드를 정의해보겠습니다. 메소드는 만들어진 인스턴스 이름 뒤에 점을 짝고 사용하면 됩니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age):
...         self.name = name
...         self.age = age
...     def sayhello(self):
...         print("Hello!")
>>> superson = person(name="손흥민", age=28)
>>> superson.sayhello()
Hello!
```

이번에는 매개변수와 반환을 갖는 run 메소드를 정의해보겠습니다. 우선 추가적으로 사람이 1초 동안 달릴 수 있는 거리를 speed 라는 속성으로 정의합니다. `__init__` 함수에 speed와 관련된 코드를 추가해줍니다. 다음으로 매개변수 t를 받아서 t초 동안 달린 거리를 반환하는 run 메소드를 정의합니다. 인스턴스의 속도는 self.speed에 저장될 것이므로, self.speed * t를 계산하면 해당 인스턴스가 t초 동안 달린 거리를 구할 수 있습니다. 이 결과를 반환값으로 지정합니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age, speed):
...         self.name = name
...         self.age = age
...         self.speed = speed # 인스턴스의 속도
...     def sayhello(self):
...         print("Hello!" )
...     def run(self, t):
...         return self.speed * t # 인스턴스의 속도로 t초간 달린 거리
```

이제 평범한 사람과 손흥민 선수가 같이 달려보겠습니다. 손흥민 선수는 1초에 100미터를 뛰는 스피드를 가졌고, 평범한 사람은 1초에 10미터를 뛰는 스피드를 가졌습니다. 사실 성인 남성 중에서도 굉장히 잘 뛰는 편인데, 손흥민 선수가 1000미터를 뛸 동안 평범한 사람은 100미터 밖에 뛰지 못했습니다.

```{python eval=F}
>>> superson = person(name="손흥민", age=28, speed=100)
>>> superson.run(t=10)
1000
>>> normal_guy = person(name="김철수", age=20, speed=10)
>>> normal_guy.run(t=10)
100
```

# 3. 패키지