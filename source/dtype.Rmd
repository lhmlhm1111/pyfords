---
title: "데이터 과학을 위한 파이썬"
subtitle: "01.자료형과 연산자"
author: "Jeonghyun Gan, DataScience Lab"
output: 
  rmdformats::readthedown:
    css: "assets/css/typo.css"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
reticulate::use_python("C://User/Administrator/Anaconda3/python")
```

# Intro

파이썬으로 데이터를 다루기 위해 가장 기본적으로 알아야 하는 것이 데이터의 형태입니다. 데이터는 숫자, 문자, 배열, 집합, 순서쌍 등 다양한 형태를 가질 수 있습니다. 파이썬에는 몇 가지 기본적인 자료형들이 정의되어 있으며, 각각의 자료형마다 다른 연산과 조작을 할 수 있습니다. 이번 장의 목표는 **내가 다루는 데이터가 어떤 형태인지를 알고, 자료형에 맞는 연산과 조작을 할 수 있는 능력**을 키우는 것입니다.

## 기본적인 파이썬 자료형

다음은 파이썬에서 사용되는 기본적인 자료형들의 예시입니다. 자세한 내용은 앞으로 차근차근 다룰 예정이니 눈으로만 봐두시면 됩니다. 

- 입력 코드는 >>> 로 표기하였습니다. 
- #표시가 붙은 부분은 코드에 대한 주석으로, 실제 실행되는 파이썬 코드가 아닙니다.

**숫자**

```{python eval=F}
>>> a=365 # 정수
>>> b=3.14 # 소수
>>> c=1.25 #소수
```

**문자열**

```{python eval=F}
>>> d='Hello world!'
>>> e="DataScience Lab"
```

**불리언**

```{python eval=F}
>>> f=True
>>> g=False
```

**리스트**

```{python eval=F}
>>> h=[1.1, 2.2, 3.3, 4.4, 5.5]
>>> i=["a","b","c","d"]
```

**튜플**

```{python eval=F}
>>> j=(1,2,3,4,5)
>>> k=(True,False,False,True)
```

**딕셔너리**

```{python eval=F}
>>> l={"김연아":"피겨", "손흥민":"축구", "박찬호":"야구"}
>>> m={1:"짜장면", 2:"짬뽕"}   
```


## 기본적인 함수와 연산자

다음은 간단한 함수들과 연산자들입니다. 앞으로도 계속 사용할 명령어들이므로 꼭 직접 코딩해보시기 바랍니다. 특히, 비교연산자 `==`와 할당연산자 `=`의 차이에 유의하세요! 할당연산자 `=`는 두 대상이 같은지 비교하는 연산자가 아니라, 변수에 값을 할당하는 할당연산자입니다. **즉 `a=5`은 "a는 5와 같다"가 아니라, "a에 5를 할당하라"는 명령입니다!**

함수/연산자|기능|예시 코드|실행결과
---|---|---|---
`print()`|대상을 출력|`print("Hello world!")`|`Hello world!`
`type()`|대상의 자료형을 반환|`type(5)`|`int'`
`==`|"두 대상이 같다"를 판단|`'Python'=='R'`|`False`
`!=`|"두 대상이 같지 않다"를 판단|`'Python'!='R'`|`True`
`=`|왼쪽 변수에 오른쪽 값을 할당|`a=5`|


# 1. 숫자

## 1.1. 정수와 소수

파이썬의 숫자는 **정수**와 **소수**로 나뉘며, 각각 **`int`**와 **`float`**으로 표기합니다. 아래는 정수 `2`와 소수 `3.14`의 자료형을 확인하는 코드와 결과입니다. `2`의 자료형은  `int`, `3.14`의 자료형은 `float`임을 확인할 수 있습니다.

```{python eval=F}
>>> type(2)
<class 'int'>
```

```{python eval=F}
>>> type(3.14)
<class 'float'>
```

## 1.2 파이썬으로 계산하기

숫자들 간에는 정수와 소수 구분 없이 다음의 연산이 가능합니다. 번거롭더라도 최소한 사칙연산 코드는 따라 쳐보면서 파이썬에 익숙해지시기 바랍니다! 사칙연산을 제외한 연산자들은 사용하는 빈도가 많지 않으니, 이런 연산이 있다고만 알아두시면 됩니다.

연산자|기능|예시 코드|실행결과|결과의 자료형
---|---|---|---|---
`a + b`|덧셈|`1+1`|`2`|`int`
`a - b`|뺄셈|`3-2.5`|`0.5`|`float`
`a * b`|곱셉|`2*4.5`|`9.0`|`float`
`a / b`|나눗셈|`0.9/0.3`|`3.0`|`float`
`a // b`|나눗셈의 몫|`8//3`|`2`|`int`
`a % b`|나눗셈의 나머지|`8%3`|`2`|`int`
`a ** b`| a의 b제곱|`5**2`|`25`|`int`


```{python eval=F}
>>> print(1+1)
2
>>> print(3 - 2.5)
0.5
>>> print(2 * 4.5)
9.0
>>> print(0.9/ 0.3)
3.0
```

# 2. 문자열

## 2.1. Hello World

문자열은 말 그대로 문자들의 나열을 의미하며, `str`로 표기합니다. 작은 따옴표(`''`), 혹은 큰 따옴표(`""`) 안에 원하는 내용을 적어주면 문자열 데이터를 만들 수 있습니다. 둘 중 무엇을 사용하든 상관은 없습니다. 프로그래밍 언어를 배울 때는 `"Hello World"`를 출력해보는 것이 관례입니다. 다같이 인사해보세요! `type("Hello world")`을 실행해보면 `"Hello world"`의 자료형이 문자열(`str`)임을 확인할 수 있습니다.

```{python eval=F}
>>> print("Hello world")
Hello world
>>> type("Hello world")
<class 'str'>
```

**예제. 다음 코드의 실행 결과가 True일지 False일지 판단하세요**

```{python eval=F}
>>> 365 == "365"
```

**풀이**

숫자도 따옴표로 감싸면 문자열이 됩니다. 즉 `365`는 숫자이고, `"365"`는 문자열입니다. `type("365")`를 실행해본 결과 `"365"`는 문자열임을 알 수 있습니다. 이후 문자열 `"365"`와 숫자 `365`가 같은지 테스트해보면, 양쪽의 자료형이 다르기 때문이 결과는 `False`입니다.

```{python eval=F}
>>> type("365")
<class 'str'>
>>> 365 == "365" # 365 는 "365"와 같다: 거짓이므로 False를 반환합니다.
False
```

## 2.2. in & not in

`in` 과 `not in` 연산은 어떤 문자열 안에 특정한 문자열이 포함되어 있는지를 판단하며, 문자열 뿐 아니라 리스트 등의 자료형에서도 활용 가능합니다. 크게 설명할 것은 없지만, 자주 쓰이는 연산이니 알아두면 좋습니다.

연산자|기능|예시 코드|결과
---|---|---|---
`a in b`|"`a`가 `b`에 포함된다"를 판단|`"A" in "ABCDEFG"`|`True`
`a not in b`|"`a`가 `b`에 포함되지 않는다"를 판단|`"A" not in "ABCDEFG"`|`False`

**예제. 다음 코드의 실행 결과를 판단하세요(True/False/Error)**

```{python eval=F}
>>> "Data" in "DatascienceLab"
>>> 1 in "123"
```

**풀이**

`"DatascienceLab"`이 `Data`라는 문자열을 포함하기 때문에 첫 줄의 실행 결과는 `False`입니다. `1`은 숫자이고, `"123"`은 문자열이기 때문에 둘째 줄의 결과는 에러입니다. 숫자와 문자열 간에는 `in`과 `not in`이라는 관계 연산이 정의되지 않습니다.

```{python eval=F}
>>> "Data" not in "DatascienceLab"
False
>>> 1 in "123"
TypeError: 'in <string>' requires string as left operand, not int
```

## 2.3. 인덱싱 & 슬라이싱

문자열은 **문자를 순서대로 나열한 데이터입니다.** 따라서 **문자열을 구성하는 하나하나의 문자에 순서대로 번호를 매길 수 있으며, 이 번호를 인덱스라고 부릅니다.** 아래 그림은 `"Hello World"`라는 문자열에 앞쪽부터 번호를 매긴 결과입니다. 파이썬의 인덱스는 0부터 시작하기 때문에, 가장 먼저 나온 문자인 `"H"`의 인덱스는 `0`이 됩니다. 그 이후 순차적으로 1, 2, ... 10 까지의 번호가 매겨졌습니다. 공백 역시 문자열에 포함된다는 사실을 유의해주세요! 파이썬의 인덱스는 뒤에서부터 부여할 수도 있습니다. 인덱스를 뒤에서부터 매기면 `-1`, `-2`, ... 와 같이 음수가 됩니다.

문자열|H|e|l|l|o| |w|o|r|l|d
:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:
인덱스|0|1|2|3|4|5|6|7|8|9|10
-인덱스|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1

### 인덱싱

문자열에 부여된 **인덱스를 통해서 개별 문자를 뽑아낼 수 있고, 이것을 인덱싱이라고 합니다.** 비유하면, 여러분과 파이썬이 다음과 같은 대화를 한다고 생각하시면 됩니다.

>
You: `"Hello world"`의 0번 문자를 찾아줘!
>
Python: `"Hello world"`의 0번 문자는 `"H"` 입니다.

그렇다면 `"Hello world"`의 0번 문자를 찾아줘!'라는 명령을 어떻게 파이썬에 전달할 수 있을까요? 문자열 바로 뒤에 대괄호`[]`를 적고, 대괄호 안에 원하는 인덱스 숫자를 넣어주면 됩니다. 실제 파이썬 코드를 실행하면 다음과 같은 결과를 얻을 수 있습니다. 예시 코드들을 따라 쳐보면서 인덱싱의 문법에 익숙해지시기 바랍니다. 실행 결과의 자료형은 당연하게도 문자열입니다!

```{python eval=F}
>>> "Hello world"[0]
'H'
>>> type("Hello world"[0])
<class 'str'>
```

문자열|인덱스|예시 코드|결과
---|---|---|---
`"Python"`|0|`"Python"[0]`|`'P'`
`"DataScience Lab"`|12|`"DataScience Lab"[12]`|`'L'`
`"010-5782-xxxx"`|7|`"010-5782-xxxx"[7]`|`'2'`
`"Life is short, you need Python."`|-1|`"Life is short, you need Python."[-1]`|`'.'`

**예제. 다음 코드의 실행 결과를 판단하세요**

```{python eval=F}
>>> mystring = "Python is too slow"
>>> mystring[-2] != mystring[4]
```

**풀이**

`"Python is too slow"`라는 문자열을 `mystring`이라는 변수에 할당했습니다. 따라서 `mystring[-2]`는 `'o'`이고, `'mystring[4]'`도 `'o'`입니다. 두 값이 같으므로 `!=` 연산의 결과는 `False`입니다.

```{python eval=F}
>>> mystring = "Python is too slow"
>>> mystring[-2]
'o'
>>> mystring[4]
'o'
>>> mystring[-2] != mystring[4]
False
```

### 슬라이싱

슬라이싱은 말 그대로 잘라내기 입니다. 일정 구간에 걸쳐서 인덱싱을 실행한다고 생각하시면 편합니다. 역시 대화로 표현하면 다음과 같습니다.

>
You: `"Hello world"`의 0번부터 4번까지의 문자를 찾아줘!
>
Python: `"Hello world"`의 0번부터 4번까지 문자는 `"Hello"` 입니다.

슬라이싱을 할 때는, `[a:b]`와 같이 대괄호 안에 구간을 입력해주면 됩니다. 구간을 입력할 때는 주의사항이 있습니다. 예시와 함께 보겠습니다.

```{python eval=F}
>>> "Hello world"[0:4]
'Hell'
```

`[0:4]`의 구간을 입력했으므로 0, 1, 2, 3, 4번 문자가 출력되어야 할 것 같은데, 이상하게 `'Hell'`까지만 출력되었습니다. 이는 슬라이싱에서 구간 `[a:b]`가 `a` 이상  `b` 미만으로 해석되기 때문입니다. 즉 0번부터 4번까지를 슬라이싱 하려면 구간을 `[0:5]`와 같이 입력해야 합니다. 코드를 수정하면 정상적으로 실행되는 것을 볼 수 있습니다.

```{python eval=F}
>>> "Hello world"[0:5]
'Hello'
```

슬라이싱의 구간 표현법을 정리하면 다음과 같습니다.

구간|설명|예시 코드|실행 결과
---|---|---|---
`[a:b]`|`a`번 문자부터 `b`번 문자 직전까지 슬라이싱|`'www.naver.com'[4:9]`|`'naver'`
`[:]`|문자열의 전 구간을 슬라이싱|`"Super Awesome Code"[:]`|`'Super Awesome Code'`
`[a:]`|`a`번 문자부터 끝까지 슬라이싱|`"Avengers: Endgame"[-7:]`|`'Endgame'`
`[:b]`|처음부터 `b`번 문자 직전까지 슬라이싱|`"서울특별시 서대문구"[:5]`|`'서울특별시'`

**예제. 다음 문자열에서 이메일 주소를 뽑아내세요**

```{python eval=F}
mystring = "학회|데이터사이언스랩|yonseidslab.github.io|yonseidslab@naver.com"
```

**풀이**

이메일 주소가 가장 뒤에 위치하므로 인덱스를 뒤쪽부터 세는게 편해 보입니다. -21번 인덱스부터 끝까지 슬라이싱하면 이메일 주소를 뽑아낼 수 있습니다.

```{python eval=F}
mystring = "학회|데이터사이언스랩|yonseidslab.github.io|yonseidslab@naver.com"
mystring[-21:]
```

## 2.4. 문자열의 메소드

메소드는 일종의 함수이며, 대상 뒤에 점 `.`을 찍고 사용할 수 있습니다. 문자열에 사용하는 대표적인 메소드들을 네 가지만 배워 보겠습니다.

메소드|기능|예시|결과
---|---|---|---
`strip()`|문자열 양쪽의 공백을 제거|`"     Hello world      ".strip()`|`"Hello world"`
`replace()`|문자열 내의 특정 문자를 다른 문자로 교체|`"You need Python".replace("Python", "R")`|`"You need Python"`
`split()`|특정 문자를 기준으로 문자열을 쪼갬|`"one,two,three,four".split(",")`|`['one','two','three','four]`
`join()`|특정 문자열을 삽입|`"/".join("ABCDE")`|`"A,B,C,D,E"`

### **strip()**

**`strip()` 메소드는 문자열 양쪽의 공백을 모두 제거합니다. 원하는 문자열 뒤에 점을 찍어서 `"문자열".strip()`과 같이 적어주면 됩니다. ** 문자열 `"   Hello world   "`는 양쪽에 공백이 있고, 가운데에도 한 칸의 공백이 있습니다. 양 옆의 공백만 지우고, 가운데의 공백은 남기기 위해서 `strip()` 메소드를 활용할 수 있습니다. `"   Hello world   "`를 변수 `s`에 할당하고, `s.strip()`을 실행한 결과, 양쪽의 공백만 지워지고 가운데 공백은 잘 남아있는 것을 확인할 수 있습니다. 

```{python eval=F}
>>> s = "   Hello world   "
>>> s.strip()
'Hello world'
```

사실 `s.strip()`은 `s`를 실제로 변화시키는 것이 아니라, 변화한 상태를 일시적으로 보여주는 것입니다. `s`를 출력해보면 양쪽의 공백이 그대로 남아있습니다. 공백을 제거한 결과를 `s`에 저장하고 싶다면, `s=s.strip()`과 같이 다시 할당을 해주어야 합니다. 처음 `s = s.strip()`과 같은 식을 마주하면 당황스러울 것입니다. 하지만 `=`는 같음을 뜻하는 연산자가 아니고, 할당을 뜻하는 연산자입니다. 즉 `s=s.strip()`이라는 코드는 **"`s.strip()`을 실행하고 이 결과를 `s`에 할당하라"**는 의미입니다.

```{python eval=F}
>>> s
'   Hello world   '
>>> s = s.strip() # s.strip()을 실행하고 이 결과를 s에 할당하라
>>> s   
'Hello world'
```

**탭을 의미하는 `\t` 문자열과 개행을 의미하는 `\n` 문자열 역시 공백으로 인식됩니다.** `\t` 와 `\n`을 사용한 공백은 웹 문서를 크롤링해서 작업할 때 자주 볼 수 있습니다. 아래 예제에서는 왼쪽에 `\n`, 오른쪽에 `\t` 세 개를 사용해서 `'Hello world'`를 감싸주었습니다. 이 결과를 변수 `s`에 할당하고 `s.strip()`을 실행한 결과, `'Hello world'`만 남아있는 것을 확인할 수 있습니다. `\t`와 `\n`이 공백으로 인식되어 지워졌기 때문입니다.

```{python eval=F}
>>> s = "\n\n\nHello world\t\t\t"
>>> s = s.strip()
>>> print(s)
Hello world
```

### **replace()**

**`replace()` 메소드는 문자열 내의 특정 문자를 다른 문자로 모두 교체합니다. `s.replace("교체할 문자","새 문자")`와 같이 적어주면 됩니다.** 아래는 `"You need Python"` 에서 `"Python"`을 `"R"`로 바꾸어준 예제입니다. 먼저 `'You need Python'`라는 문자열을 `s`라는 변수에 할당하였습니다. `s.replace("Python","R")` 은 s에 할당된 문자열 `"You need Python"`에서 `'Python'`을 `'R'`로 바꾸어주는 코드입니다. 역시 `s.replace("Python","R")`를 실행하는것만으로는 `s`에 할당된 값이 변화하지 않으며, `s`를 변화시키고 싶다면 `s=s.replace("Python","R")`과 같이 다시 할당을 해주어야 합니다.

```{python eval=F}
>>> s = 'You need Python' # 문자열을 변수 s에 할당
>>> s.replace("Python", "R") # s에서 Python -> R로 교체
'You need R'
>>> s # s는 변화하지 않음
'You need Python'
>>> s = s.replace("Python", "R") # Python을 R로 교체한 후 이 결과를 s에 할당
>>> s
'You need R'
>>> s = s.replace(" ", ",") # 모든 " "를 ","로 교체
>>> s
'You,need,R'
```

**예제. `a` 문자열을 `b`와 같은 문자열로 변형하고 결과를 검증하세요. 단, 문자열 조작하는 과정에는 한 줄의 코드만 사용할 수 있습니다.**

```{python eval=F}
>>> a = "   C GO Java Python PHP   "
>>> b = "C|GO|Java|Python|PHP"
```

**풀이**

**1) 문자열의 양쪽 공백을 제거해준 후, 2) 중간중간의 공백을 "|"로 교체**해주면 문제를 해결할 수 있습니다. 얼핏 보면 다음과 같이 두 줄의 코드가 필요할 것 같습니다. 먼저 양쪽의 공백을 지운 결과를 `tmp`라는 임시 변수에 저장합니다. 이후 `tmp`에서 공백을 "|"로 교체하고 이 결과를 `result`라는 변수에 최종적으로 저장합니다. `b`와 `result`를 비교해보면 두 값이 같다는 사실을 알 수 있습니다.

```{python eval=F}
>>> a = "   C GO Java Python PHP   "
>>> b = "C|GO|Java|Python|PHP"
>>> tmp = a.strip()
>>> result = tmp.replace(" ","|")
>>> b == result
True
```

위의 코드가 틀린 것은 아니지만, `tmp`라는 임시 변수를 사용하지 않고 코드를 더 간소화할 수 있습니다. 아래 풀이에서는 **메소드 체이닝, 즉 메소드를 연결하는 코드를 통해서 두 번의 조작을 한 줄의 코드로 끝냈습니다.** `a.strip()`의 결과는 양쪽 공백이 제거된 `"C GO Jave Python PHP"` 입니다. `a.strip().replace(" ","|")`는 결국 `"C GO Jave Python PHP".replace(" ","|")`과 같은 코드가 되는 것입니다. 내가 적은 코드의 결과를 상상할 수 있는 능력이 발달하면, 자연스레 메소드 체이닝에 익숙해지게 될 것입니다.

```{python eval=F}
>>> a = "   C GO Java Python PHP   "
>>> b = "C|GO|Java|Python|PHP"
>>> result = a.strip().replace(" ","|")
>>> b == result
True
```

### **split()**

**`split()` 메소드는 특정 문자를 기준으로 문자열을 쪼개어 리스트를 반환합니다. `s.split("기준문자")`와 같이 적어주면 됩니다.** 아무런 문자도 주어지지 않는다면 공백을 기준으로 문자열을 쪼갭니다. 역시 쪼갠 결과를 저장하려면 다시 할당을 해주어야 합니다.

```{python eval=F}
>>> s = "Hello world"
>>> s.split(" ") # " " 를 기준으로 문자열을 쪼갬 > 이 결과를 리스트로 반환
['Hello', 'world']
>>>
>>> s = "one/two/three/four"
>>> s.split("/")
['one', 'two', 'three', 'four']
```

**예제. 다음 코드의 실행 결과를 예상해보세요**

```{python eval=F}
>>> a = "yonseidslab@gmail.com"
>>> a.replace("@",".").split(".")
```

**풀이**

문자열에서 `"@"`를 `"."`으로 교체해준 후, `"."`을 기준으로 나누었으므로 결과는 다음과 같습니다.

```{python eval=F}
['yonseidslab', 'gmail', 'com']
```

#### **join()**

**`join()` 메소드는 문자열 사이사이에 다른 문자를 삽입합니다. "삽입할 문자".join(문자열)과 같이 적어주면 됩니다.** `join` 메소드는 문자열보다는 리스트에 대해 사용하는 경우가 많습니다

```{python eval=F}
>>> alphabet = "ABCDEFG"
>>> "|".join(alphabet)
'A|B|C|D|E|F|G'
```

# 3. 불리언

불리언은 참/거짓을 나타내는 자료형이며, 각각 `True`, `False`로 씁니다. 크게 주의할 것은 없고, 파이썬에서 `0`이 `False`를 의미한다는 것은 알고 넘어가면 좋습니다.

```{python eval=F}
>>> 0 == False
True
```

# 4. 리스트

리스트는 `[요소1, 요소2, 요소3, ...]`과 같이 여러 요소들을 묶어놓은 자료형입니다. 각 요소들은 쉼표 `,`로 구분되며, 바깥은 대괄호 `[]`로 감싸줍니다. 리스트는 거의 모든 자료형을 요소로 가질 수 있으며, 요소들의 자료형이 모두 같을 필요도 없습니다. 다음은 모두 리스트의 예시입니다.

```{python eval=F}
>>> a = [] # 빈 리스트
>>> b = [1,2,3,4,5] # 숫자 리스트
>>> c = ['a','b','c','d','e'] # 문자열 리스트
>>> d = ['a','b',3,4,'d',False] # 여러 자료형을 포함한 리스트
>>> e = [[1,2,3],[4,5,6]] # 리스트의 리스트
```

## 4.2. in & not in

문자열에서 다루었던 `in`, `not in` 연산자는 리스트에도 적용할 수 있으며, 리스트에 특정 요소가 들어있는지를 판단합니다. 

```{python eval=F}
>>> "Apple" not in ["Apple", " Banana", "code"]
False
>>> [1,2,3] in [[1,2,3],[4,5,6]]
True
```

**예제. 다음 코드의 실행 결과를 판단하세요(True/False)**

```{python eval=F}
>>> [1,2,3] not in [1,2,3]
>>> 1 in [[1,2,3]]
```

**풀이**

첫 줄은 '`[1,2,3]`은 `[1,2,3]`의 요소가 아니다'를 판단하는 코드입니다. `[1,2,3]`의 요소는 `1`, `2`, `3` 이므로 `[1,2,3]`은 `[1,2,3]`의 요소가 아니고, 결과는 `True`입니다. 두 번째 줄은 '`1`은 `[[1,2,3]]`'의 요소이다'를 판단하는 코드입니다. `[[1,2,3]]`의 요소는 `[1,2,3]`뿐이므로 결과는 `False`입니다.

```{python eval=F}
>>> [1,2,3] not in [1,2,3]
True
>>> 1 in [[1,2,3]]
False
```

## 4.2. 리스트 인덱싱 & 슬라이싱

리스트는 요소들의 순차적인 배열입니다. 따라서 문자열과 마찬가지로, 각각의 요소들에 번호를 매길 수 있습니다. 번호를 매기는 방식 역시 문자열과 동일합니다. 즉 앞에서부터 `0`, `1`, `2` ... 순으로 인덱스가 붙고, 뒤에서부터 `-1`,`-2`,`-3` ... 순으로 인덱스가 붙습니다. 예를 들면 다음과 같습니다.

```{python eval=F}
>>> ["Life", "is", "short", "you", "need", "Python"]
```


요소|"Life"|"is"|"short"|"you"|"need"|"Python"
:---:|:---:|:---:|:---:|:---:|:---:|:---:
인덱스|0|1|2|3|4|5
인덱스|-6|-5|-4|-3|-2|-1

### 인덱싱

문자열의 인덱싱과 슬라이싱에 익숙해졌다면, 리스트의 인덱싱과 슬라이싱 역시 어렵지 않을 겁니다. 리스트의 인덱싱 역시 문자열과 마찬가지로 대괄호 `[]`를 사용합니다.

리스트|인덱스|예시 코드|결과
---|---|---|---
`[0.25, 0.5, 0.75, 1.0]`|1|`[0.25, 0.5, 0.75, 1.0][1]`|`0.5`
`["You", "need", "Python"]`|-1|`["You", "need", "Python"][-1]`|`'Python'`
`[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]`|2|`[[1,2,3],[4,5,6],[7,8,9],[10,11,12]][2]`|`[7,8,9]`

```{python eval=F}
>>> [0.25, 0.5, 0.75, 1.0][1]
0.5
>>> ["You", "need", "Python"][-1]
'Python'
>>> [[1,2,3],[4,5,6],[7,8,9],[10,11,12]][2]
[7, 8, 9]
```

인덱싱을 사용하여 개별 요소를 추출하였다면, 해당 요소에 대해 다시 조작을 가하는 것도 가능합니다. 아래는 리스트에서 개별 요소를 추출한 후, 해당 요소에 대해 다시 인덱싱/슬라이싱을 적용한 예제입니다.

```{python eval=F}
>>> mylist = ["Life", "is", "short", "you", "need", "Python"] # 리스트 생성
>>> element = mylist[0] # 0번 요소인 "Life" 추출
>>> element[:2] # "Life"에서 2번 문자까지 슬라이싱
'Li'
>>> element[:2] == mylist[0][:2] # 위 과정을 붙여서 쓴 코드
True
```

**예제. 다음 리스트에서 "Wally"를 추출하세요.**

```{python eval=F}
>>> WhereIsWally = [["wally","Willy Wonka"],[["waly"],"Wally","Wallmart"]]
```

**풀이**

`"Wally"`는 두 번째 서브리스트의 두 번째 요소입니다. 따라서 다음과 같이 두 번의 인덱싱으로 손쉽게 월리를 찾아낼 수 있습니다.

```{python eval=F}
>>> WhereIsWally = [["wally","Willy Wonka"],[["waly"],"Wally","Wallmart"]]
>>> WhereIsWally[1][1]
'Wally'
```

**예제. 다음 주소에서 문자열 인덱싱을 사용하지 않고 동을 추출하세요.**

```{python eval=F}
>>> address = "서울특별시 서대문구 신촌동 연세로 50"
```

**풀이**

주어진 문자열은 띄어쓰기 기준으로 스플릿할 수 있습니다. 스플릿을 실행하면 각 어절이 리스트의 요소로 들어갈 것이고, `"신촌동"`은 리스트의 두 번째 요소가 될 것입니다. 이 결과를 코드로 정리해주면 됩니다.

```{python eval=F}
>>> address = "서울특별시 서대문구 신촌동 연세로 50"
>>> address.split(" ")[2]
'신촌동'
```

### 슬라이싱

리스트 슬라이싱 역시 문자열 슬라이싱과 다르지 않습니다. 대괄호 안에 콜론을 써서 구간을 표현해주시면 됩니다.

```{python eval=F}
>>> ['one', 'two', 'three', 'four', 'five'][:2]
['one', 'two']
>>> ["Apple","Banana", "Computer", "Data"][1:3]
['Banana', 'Computer']
>>> [1, 2, 3, 4, 5][3:-1]
[4]
```

이번에는 특정 요소들을 건너뛰는 슬라이싱을 배워보겠습니다. 예를 들어 리스트 안에서 홀수 인덱스를 가진 요소들만 추출할고 싶을 때, 이 방법을 활용할 수 있습니다. **기본적인 구간 표현법은 `start:end:step`과 같습니다. 이는 `start`부터 `end`까지 `step`만큼 이동하면서 가져오라는 의미입니다.** `step`이 1이면 바로 다음 요소로 가는 것이므로 해당 구간의 모든 요소들을 가져올 것이고, `step`이 2이면 한 칸씩 건너뛰면서 요소들을 가져올 것입니다.

예제와 함께 보겠습니다. 첫 예제에서 사용한 구간 `1:8:2`는 1번 인덱스부터 8번 인덱스까지 2칸씩 진행하면서 요소들을 가져오라는 뜻입니다. 즉 따라서 1, 3, 5, 7번 인덱스에 해당하는 `1`, `3`, `5`, `7`이 추출되었습니다. 두 번째 예제에서는 `start`와 `end`를 생략하여 리스트의 전 구간을 표현하였고, `step`은 2로 주었습니다. 따라서 0, 2, 4, 6, 8번 인덱스에 해당하는 `0`, `2`, `4`, `6`, `8`이 추출되었습니다.

```{python eval=F}
>>> [0, 1, 2, 3, 4, 5, 6, 7, 8][1:8:2]
[1, 3, 5, 7]
>> [0, 1, 2, 3, 4, 5, 6, 7, 8][::2]
[0, 2, 4, 6, 8]
```

