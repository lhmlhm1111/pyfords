---
title: "데이터 과학을 위한 파이썬"
subtitle: "02.제어문, 클래스, 패키지"
author: "Jeonghyun Gan, DataScience Lab"
output: 
  rmdformats::readthedown:
    css: "assets/css/typo.css"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

- [00. 데이터 과학을 위한 파이썬](https://yonseidslab.github.io/pyfords/)
- [01. 자료형과 연산자](https://yonseidslab.github.io/pyfords/page1)
- [02. 제어문, 클래스, 패키지](https://yonseidslab.github.io/pyfords/page2)
- [03. 데이터 다루기: numpy & pandas](https://yonseidslab.github.io/pyfords/page3)
- [04. 시각화: matplotlib, seaborn](https://yonseidslab.github.io/pyfords/page4)

# Intro

이번 장에서는 제어문, 클래스, 패키지에 대해 공부합니다. 

- 직선적인 프로그램만으로 데이터를 다루는 데에는 한계가 있습니다. 제어문은 조건, 반복 등의 흐름 제어를 통해 효율적이고 유연한 프로그래밍을 가능하게 합니다. 앞으로도 계속해서 사용하게 될 문법이므로 조건문과 반복문은 충분히 연습해야 합니다. 

- 객체 지향 프로그래밍과 클래스는 파이썬의 핵심이지만, 아직 깊게 이해할 필요는 없습니다. 이번 장에서는 클래스의 개념과 기본적인 구조를 파악하는 것을 목적으로 합니다.

- 패키지 역시 앞으로 파이썬을 사용하면서 계속해서 마주칠 개념입니다. 패키지의 기본적인 개념과 pip, conda를 활용하여 패키지를 설치/삭제하는 방법을 알면 충분합니다.

# 1. 조건문

조건문은 프로그래밍 흐름에서 가지를 치는 역할을 합니다. 즉 주어진 조건을 판단하여 상황마다 다른 코드가 실행되도록 만드는 것이 조건문의 역할입니다. 파이썬의 조건문은 `if`, `else`, `elif` 의 세 가지 구문으로 이루어집니다. 이 구문들을 차례대로 살펴보겠습니다.

## 1.1. if

```{python eval=F}
if 조건:
   조건이 True일 때 실행할 코드 # 들여쓰기 필수!!
```

**`if` 는 조건과 함께 사용하며, 주어진 조건이 `True`일 때 이하의 코드를 실행합니다. 조건은 `True`/`False`로 진리값을 명확하게 판단할 수 있는 연산이어야 합니다.** `if` 문의 기본적인 구조는 위와 같습니다. `if` 다음 조건을 걸고 콜론을 적은 후, 다음 줄부터 조건이 참일 때 실행할 코드를 적어주면 됩니다.

```{python eval=F}
>>> score = 90
>>> if score >= 60: # score >= 60: 참이므로 다음 코드 실행 
...     print("Pass") 
Pass
```

위 예시는 점수가 60점 이상이면 패스를 출력하는 조건문입니다. 첫 줄에서는 `score` 변수에 `90`을 할당합니다. `if` 문에서 `score >= 60`을 판단하고, 만약 참이라면 `"Pass"`를 프린트합니다. 조건이 참이므로 다음 코드를 실행하였습니다.

## 1.2. else

```{python eval=F}
if 조건:
   조건이 참일 때 실행할 코드 # 들여쓰기 필수!!
else:
   조건이 거짓일 때 실행할 코드 # 들여쓰기 필수!!
```

조건이 참일 때만 조작이 필요하다면, `if` 만 사용해도 충분합니다. 하지만 조건이 거짓일 때도 그에 맞는 조작이 필요하다면, `else` 를 함께 사용합니다. **`if` 이하의 코드는 조건이 참일 때 실행되고, `else` 이하의 코드는 조건이 거짓일 때 실행됩니다. `else` 다음에는 조건을 붙이지 않습니다!**

```{python eval=F}
>>> def pnp(score):
...     if score >= 60:
...         return("Pass")
...     else:
...         return("Non-Pass")
>>> pnp(60)
'Pass'
>>> pnp(40)
'Non-Pass'
```

위의 코드에서는 `pnp` 라는 함수 안에 조건문을 집어넣었습니다. 함수는 `score`라는 인자를 받으며, `score`가 `60`보다 크거나 같으면 `"Pass"`를 반환하고, 그렇지 않으면 `"Non-Pass"`를 반환합니다. 

- `pnp(60)`을 실행하면 함수는 `60 >= 60`을 판단합니다. 이 결과가 참이므로 `if` 이하의 코드인 `return("Pass")`가 실행되고, 함수는 종료됩니다. 

- `pnp(50)`을 실행하면 함수는 `50 >= 60`을 판단합니다. 결과가 거짓이므로 `if` 이하의 코드를 건너뛰고, `else` 로 넘어갑니다. 따라서 `return("Non-Pass")`가 실행됩니다.

## 1.3. elif

```{python eval=F}
if 조건 1:
    조건 1이 True일 때 실행할 코드
elif 조건 2:
    조건 1이 False 이고 조건 2가 True일 때 실행할 코드
elif 조건 3:
    조건 1, 조건 2가 False 이고 조건 3가 True일 때 실행할 코드
.
.
.
else:
    모든 조건들이 False일 때 실행할 코드
    
```

학생에게 A부터 F까지의 성적을 매기려고 하는 경우에는, `if` 와 `else` 만으로는 힘듭니다. 먼저 학생의 성적이 F인지 아닌지를 판단하고, F가 아닌 경우 D인지 아닌지 판단하고 ... 이러한 과정을 A까지 반복해야 합니다. **`elif` 를 사용하면 이런 다중 분기를 손쉽게 구현할 수 있습니다.** `elif` 를 활용한 조건문의 구조는 위와 같습니다. `if` 문부터 순차적으로 조건을 판단하고, 거짓이면 다음 `elif`로 넘어가는 방식입니다.

```{python eval=F}
>>> def grade(score):
...     if score >= 90:
...         return("A")
...     elif score >= 80: # score >= 90 이 거짓: score >= 80 & score < 90
...         return("B")
...     elif score >= 70: # score >= 80 이 거짓: score >= 70 & score < 80
...         return("C")
...     elif score >= 60: # score >= 70 이 거짓: score >= 60 & score < 70
...         return("D")
...     else: # score >= 60 이 거짓: score < 60
...         return("F")
...
>>> grade(90)
'A'
>>> grade(80)
'B'
>>> grade(70)
'C'
>>> grade(60)
'D'
>>> grade(50)
'F'
>>>   
```

위의 코드는 점수에 따라 학점을 매기는 함수를 구현한 예시입니다. 가장 먼저 90점 이상인지를 판단하고, 이 결과가 거짓이면 다음 `elif` 로 넘어가서 80점 이상인지를 판단합니다. 이러한 과정을 60점까지 반복하고 나머지 경우에는 F를 반환합니다.

:::warning
**예제 1.1. 주어진 파일 이름 문자열의 확장자가 `.csv`, `.json`, `.xlsx` 중 하나이면 `True` 아니면 `False` 를 반환하는 함수를 작성하세요. 이후 이 함수를 `filelist` 에 매핑하세요.**

```{python eval=F}
>>> filelist = ["data.csv", "자기소개서.hwp", "졸업학점계산기.xlsx", "기말보고서.docx", "apiKey.json"]
>>> result = your_code ...
>>> print(result)
[True, False, True, False, True]
```

**풀이**

1. 파일의 확장자를 판단하는 함수를 작성합니다.

    - 먼저 파일 이름에서 확장자를 분리해내야 합니다. 확장자는 파일 이름의 가장 마지막에 `.확장자` 형식으로 붙습니다. 따라서 파일 이름을 `.`을 기준으로 스플릿해준 후에, 결과로 나온 리스트의 마지막 요소를 인덱싱하면 확장자를 추출할 수 있습니다. 

    - 확장자를 분리해냈으면 이 확장자가 `csv`, `xlsx`, `json` 중 하나에 속하는지 판단하면 됩니다. 조건문을 사용할 수도 있지만, `in` 연산을 사용해서 한번에 처리할 수도 있습니다. 확장자가 `["csv", "xlsx", "json"]` 중 하나에 속하면 `True`, 아니면 `False`를 반환합니다.
    
2. 만든 함수를 리스트에 매핑합니다.

```{python eval=F}
>>> filelist = ["data.csv", "자기소개서.hwp", "졸업학점계산기.xlsx", "기말보고서.docx", "apiKey.json"]
```

<div class = "row">
  <div class = "col-md-6">
**조건문으로 구현한 함수**
```{python eval=F}
>>> def myFunction(filename):
...     ext = filename.split(".")[-1]
...     if ext == "csv":
...         return True
...     elif ext == "xlsx":
...         return True
...     elif ext == "json":
...         return True
...     else:
...         return False
```
  </div>
  <div class = "col-md-6">
**`in` 연산으로 구현한 함수**
```{python eval=F}
>>> def myFunction(filename):
...     ext = filename.split(".")[-1]
...     return ext in ["csv","xlsx","json"]
```
  </div>
</div>

```{python eval=F}
>>> result = list(map(myFunction,filelist))
>>> print(result)
[True, False, True, False, True]
```
:::

# 2. 반복문

## 2.1. for in 반복문

### for in 반복문의 구조

```{python eval=F}
>>> for 변수 in 리스트/튜플/...:
...    작업 코드 # 들여쓰기 필수!
```

`for in` 반복문은 파이썬에서 가장 흔하게 사용되는 반복문이며, **리스트처럼 일정한 순서와 길이를 갖는 객체의 요소들에 같은 작업을 반복적으로 적용합니다.** 아래 예시 코드를 보겠습니다.

<div class = "row">
  <div class = "col-md-6">
**`for in` 반복문**
```{python eval=F}
>>> for i in [1,2,3]:
...     print(i)
1
2
3
```
  </div>
  <div class = "col-md-6">
**반복문을 풀어낸 코드**
```{python eval=F}
>>> i = 1
>>> print(i)
1
>>> i = 2
>>> print(i)
2
>>> i = 3
>>> print(i)
3
```
  </div>
  
`for i in [1,2,3]`에서 `i`는 변수입니다. **반복문 `for i in [1,2,3]` 는 변수 `i`에 리스트 `[1,2,3]`의 요소들인 `1, 2, 3`을 순차적으로 할당합니다.** 즉 루프의 첫 번째 바퀴에서는 `i=1` 이 되고, 따라서 `print(i)`의 결과로 `1`이 출력됩니다. 루프의 두 번째, 세 번째 바퀴에서는 각각 `i=2`, `i=3`이 되고, 따라서 `print(i)`의 결과로 `2,3`이 출력됩니다. 함수를 만들 때와 마찬가지로, 콜론 이후의 절에서는 반드시 들여쓰기를 해주어야 합니다.



:::warning
**예제 2.1. 다음 코드를 반복문으로 구현해보세요**

```{python eval=F}
>>> number = 100
>>> print(number < 200)
True
>>> number = 200
>>> print(number < 200)
False
>>> number = 300
>>> print(number < 200)
False
```

**풀이**

위 코드에서는 number 변수에 100, 200, 300을 할당하면서 number < 200 연산을 동일하게 수행하고 있습니다. 따라서 100, 200, 300 을 리스트로 만들고 for 문을 적용하면 문제를 해결할 수 있습니다.

```{python eval=F}
>>> for number in [100, 200, 300]:
...    print(number < 200)
True
False
False
```
:::

### for i in range(n)

`for in` 반복문은 `range(a,b)` 함수와 함께 사용되는 경우가 많습니다. `range(a,b)` 함수는 `a`부터 `b`까지의 정수 구간을 생성하는 함수이며, `b`는 구간에 포함되지 않습니다. `range(a)`와 같이 쓰면 `0`부터 `a`까지의 정수 구간을 생성하며, 역시 `a`는 구간에 포함되지 않습니다.

```{python eval=F}
>>> for i in range(1,3):
...     print(i)
1
2
>>> for i in range(3):
...     print(i)
0
1
2
```

`for 변수 in 리스트` 와 같은 형태의 반복문에서 반드시 지정한 변수를 활용할 필요는 없습니다. 반복문은 반복하는 변수 `i`와 관계없는 작업을 단순히 `n`번 반복하기 위해 사용하기도 합니다. 아래 예시 코드를 보겠습니다. `for i in range(3)` 이라는 코드는 루프마다 `i=0`, `i=1`, `i=2`을 할당합니다. 하지만 실제 반복문 안에서 실행되는 코드는 `print("Hello world")` 로 `i`와는 전혀 관계가 없습니다.

```{python eval=F}
>>> for i in range(3):
...     print("Hello world")
Hello world
Hello world
Hello world
```

:::warning
**예제 2.2. for 반복문과 range 함수를 활용하여 1부터 100까지 자연수의 합을 구하세요**

**풀이**

이번 문제를 풀기 위해서는 약간의 테크닉이 필요합니다. 먼저 반복문 바깥에 `result`라는 변수를 만들고 `0`을 할당합니다. 이후 `1`부터 `100`까지의 숫자를 차례대로 `result` 변수에 더해주면 합을 구할 수 있습니다. 반복문 외부에 결과를 저장할 변수를 만들고 루프를 돌면서 변수를 업데이트하는 기법은 자주 쓰이므로 기억해두면 좋습니다.

```{python eval=F}
>>> result = 0
>>> for i in range(1,101):
...     result = result + i
>>> print(result)
5050
```

**예제 2.3. for 반복문과 range 함수를 활용하여 1\*\*2, 2\*\*2, 3\*\*2 ... 10000\*\*2을 포함하는 리스트를 만들어보세요.**

**풀이**

최종적으로 만들 결과물이 리스트이기 때문에, 반복문 밖에 빈 리스트를 생성합니다. 이후 `range(1,10001)` 를 이용해 구간을 생성하고, 루프를 돌면서 `i**2` 를 리스트에 추가해줍니다. 결과의 출력은 생략하겠습니다.

```{python eval=F}
>>> mylist = []
>>> for i in range(1,10001):
...    mylist.append(i**2)
```
:::

### List Comprehension

위의 예제에서는 빈 리스트에 `append` 메소드를 반복적하여 리스트를 만들어 보았습니다. 이번에는 **List comprehension**이라는 기법을 사용하여 리스트를 만들어볼 것입니다. 아래는 지금까지 해왔던 방식으로 `0`부터 `9`까지의 숫자를 제곱한 리스트를 만드는 코드입니다.

```{python eval=F}
>>> mylist = []
>>> for i in range(10):
...    mylist.append(i**2)
>>> print(mylist)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

아래는 리스트 컴프리헨션을 활용한 예시 코드입니다. **리스트 컴프리헨션은 대괄호 `[]`안에 연산과 반복문을 함께 적습니다. 반복되는 변수를 활용한 연산이 나오고, 이후에 반복문이 나온다는 점을 유의하세요.** 복잡해보일 수 있는 구조이지만, 콜론 뒤에 나오던 연산 과정이 앞으로 당겨졌을 뿐입니다. 리스트 컴프리헨션을 사용하면 `append`를 사용하는 것보다 더 간결하고 빠른 코드를 작성할 수 있습니다다.

```{python eval=F}
>>> [연산 for 변수 in 리스트] # 리스트 컴프리헨션의 구조
>>> mylist = [i**2 for i in range(10)] # 연산: i ** 2, 반복문: for i in range(10)
>>> print(mylist)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

:::warning
**예제 2.4. 리스트 컴프리헨션을 사용하여 구구단 6단 리스트를 만드세요**

```{python eval=F}
[6, 12, 18, 24, 30, 36, 42, 48, 54]
```

**풀이**

구구단은 6\*1, 6\*2, ..., 6\*9 와 같이 진행됩니다. 즉 `6 * i`를 `i=1`부터 `i=9`까지 반복하면 구구단 6단을 만들 수 있습니다. 이 때 연산은 `6 * i`가 되고, 리스트는 `[1,2,...,9]`가 될 것입니다. 따라서 다음과 같은 코드를 사용하여 구구단 6단의 리스트를 만들 수 있습니다.

```{python eval=F}
>>> [6 * i for i in range(1,10)]
[6, 12, 18, 24, 30, 36, 42, 48, 54]
```
:::

## 2.2. while 반복문

```{python eval=F}
while 조건:
    조건이 참인 동안 실행할 코드
```

`while` 반복문은 `for in` 반복문과 달리, 조건과 함께 사용됩니다. `while` 이후의 조건이 참인 동안 조건 이후의 코드를 계속해서 수행하게 됩니다.

```{python eval=F}
>>> while True:
...     print("Press Ctrl+C to escape")
...
Press Ctrl+C to escape
Press Ctrl+C to escape
Press Ctrl+C to escape
.
.
.
```

위 예시 코드에서는 조건이 `True`입니다. 즉 해당 반복문은 사용자가 멈추지 않는 이상 무한히 반복됩니다. `while` 반복문은 자주 사용하지는 않지만, 알아둘 필요는 있습니다.

## 2.3. 반복문 안에서의 흐름 제어

반복문 안에 추가적으로 흐름을 제어하는 명령어들을 배치할 수 있습니다. `continue` 는 즉시 다음 바퀴로 넘어가는 명령어이고, `break` 는 반복을 멈추는 명령어입니다. 역시 자주 쓰이지는 않지만 알아둘 필요는 없습니다.

명령어|기능
---|---
`continue`|즉시 다음 바퀴로 넘어감
`break`|반복 정지, 다음 코드로 넘어감
<div class="row">
  <div class="col-md-6">
**`continue`**
```{python eval=F}
>>> for i in range(10):
...     if i < 5:
...         continue
...     print(i)
...
5
6
7
8
9
```
  </div>
  <div class="col-md-6">
**`break`**
```{python eval=F}
>>> for i in range(10):
...     if i == 5:
...         break
...     print(i)
...
1
2
3
4
```
  </div>
</div>
# 3. 객체 지향 프로그래밍과 클래스

파이썬은 대표적인 객체 지향 프로그래밍 언어이며, 객체 지향과 클래스는 파이썬을 배우면서 언젠가는 짚고 넘어가야 하는 부분입니다. 하지만 객체 지향과 클래스가 단번에 이해할 수 있는 개념은 아닙니다. 사실 프로그래밍을 배운다는 것이 모든 스킬을 선형적으로 습득해가는 과정이 절대 아니기 때문에, 지금 이해가 가지 않는다고 해서 조급해할 필요는 없습니다. 또한 지금은 개발을 목적으로 파이썬을 배우는 것아 아니므로 클래스를 꼭 자유자재로 다룰 수 있어야 하는 것도 아닙니다. 만들어진 클래스의 구조를 이해하고 활용할 수 있는 정도면 충분합니다.

## 3.1. 클래스, 객체, 인스턴스

프로그램은 수많은 명령어들로 이루어집니다. 하지만 객체 지향 프로그래밍에서는 명령어가 아닌 객체들이 프로그램의 중심이 됩니다. 객체란 마치 현실 세계에 존재하는 사물들과 유사한 것입니다. 현실 세계의 사물들은 특정한 속성을 갖고, 스스로 행동하거나 다른 사물들에 의해서 조작될 수 있습니다. 예를 들어 사람은 이름과 나이를 속성으로 가질 수 있고, 인사를 하는 등 행동을 할 수 있습니다. 인사를 할 수 있는 사람을 간단한 파이썬 프로그램으로 구현해보면 다음과 같습니다. 코드 해설을 모두 이해할 필요는 없고, 다만 우리가 현실세계의 사람을 모방해서 사람과 같은 속성을 갖고, 사람처럼 행동하는 무언가를 만들었다는 사실을 주목해주시면 됩니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age): # person 클래스의 속성을 정의
...         self.name = name
...         self.age = age
...     def sayhello(self):
...         print("Hello!")
>>> superson = person(name="손흥민", age=28) # 손흥민을 닮은 객체를 만들어봐요!
>>> superson.name # 속성
'손흥민'
>>> superson.age # 속성
28
>>> superson.sayhello() # 메소드(행동)
Hello!
```

가장 먼저 `class` 명령어를 사용해서 `person` 클래스를 만들었습니다. `superson = person(name="손흥민",age=28)` 은 이름이 `"손흥민"` 이고 나이가 `28` 인 사람을 만들어서 `superson`이라는 변수에 저장한 것입니다. 이제 파이썬 세상에서 `superson` 은 이름과 나이를 갖는 사람처럼 취급될 수 있습니다. `superson.name`, `supserson.age` 를 통해서 `superson`의 이름과 나이라는 속성에 접근할 수 있고, `superson.sayhello()` 를 통해서 인사를 하는 행동을 구현할 수도 있습니다.

### 클래스와 객체/인스턴스 구분하기

- 클래스: 객체/인스턴스를 찍어내는 틀이자 객체/인스턴스가 속하는 그룹
- 객체/인스턴스: 클래스에 의해 만들어진 존재, 대상

**클래스는 객체가 속하는 그룹이자 객체를 찍어내는 틀입니다.** `person` 클래스를 구현해놓으면 서로 다른 속성을 갖는 여러 사람들을 손쉽게 만들어낼 수 있습니다. 아래는 `person` 클래스를 가지고 서로 다른 이름과 나이를 갖는 객체들을 만드는 예시입니다. 각자 다른 이름과 나이를 갖기는 하지만, 이들은 모두 `person` 클래스에 속하며, 일정한 속성과 메소드들을 공유합니다. 

```{python eval=F}
>>> supserson = person(name="손흥민", age=27)
>>> yoonaqueen = person(name="김연아", age=29)
>>> psy = person(name="박재상", age=41)
```

**클래스를 사용해서 만들어낸 실제 대상을 객체 혹은 인스턴스라고 부릅니다.** 객체와 인스턴스는 엄밀하게 구분하기도 하지만, 여기에서는 구분 없이 사용하겠습니다. 위의 예제에서 `person` 클래스를 사용해서 만든 `superson`, `yoonaqueen`, `psy` 가 모두 인스턴스입니다. 

## 3.2. 클래스 만들기

### class 명령어

이제 본격적으로 클래스를 만드는 방법을 다뤄보겠습니다. 우선 아무것도 없는 빈 클래스를 만들어보겠습니다. 클래스를 만들 때는 class 라는 명령어를 사용합니다. `class 클래스이름:` 과 같이 적어주면 클래스를 생성할 수 있습니다. 아무 것도 포함하는 것이 없는 클래스를 만들기 위해 콜론 이후에는 `pass` 를 적어줍니다. 빈 클래스를 통해서도 인스턴스들을 찍어낼 수 있습니다.

```{python eval=F}
>>> class person:
...     pass
>>> superson = person()
```

### 클래스에 속성 부여하기

하지만 위와 같은 클래스는 아무 속성도 갖지 않고, 아무런 행동도 할 수 없습니다. 이제부터는 속성을 갖는 `person` 클래스를 만들어보도록 하겠습니다. 클래스에 속성을 부여하기 위해서는, 클래스 안에 `__init__` 함수를 정의해야 합니다. **`__init__ ` 함수는 초기화, 혹은 시작을 뜻하며 클래스가 필수적으로 가져야 할 속성들을 정의합니다.** __init__ 함수의 기본적인 구조는 다음과 같습니다.

```{python eval=F}
>>> __init__(self, 속성1, 속성2, ...):
...     self.속성1 = 속성1
...     self.속성2 = 속성2
...     ...
```

**`__init__` 함수는 `self`, `속성` 이라는 두 종류의 매개변수를 갖습니다. `self` 는 클래스에 의해 생성될 인스턴스를 가리키며, 클래스 안에서 정의되는 모든 함수에 반드시 포함되어야 하는 매개변수입니다.** `self` 이후의 매개변수들은 자신이 원하는 속성들을 표현할 수 있는 변수 이름들을 나열해주시면 됩니다. 만약 `person` 클래스에 `name`과 `age`라는 속성을 정의하고 싶다면 우선 `self`, `name`, `age`라는 세 가지 매개변수를 갖는 `__init__` 함수를 클래스 안에 정의해야 합니다. 즉 우선 다음과 같이 써야 합니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age):
```

이제 `__init__` 함수의 내부를 살펴볼 차례입니다. `__init__` 함수의 내부 구조는 간단하지만, 처음 보면 당황스러울 수 있습니다. 자신이 정의하려는 속성들을 `self.속성 = 속성`과 같이 차례로 할당해주면 됩니다. `self` 는 클래스에 의해 생성될 인스턴스라고 언급하였습니다. 따라서 `self.name` 코드는 새로 만들 인스턴스의 `name` 속성에 `name` 값을 할당하며, `self.age` 코드는 새로 만들 인스턴스의 `age` 속성에 `age` 값을 할당합니다. 

`name` 값과 `age` 값은 사용자가 인스턴스를 생성할 때 지정하기 때문에, 실제로 인스턴스를 생성하는 코드를 함께 봐야 이해하기 쉽습니다. 예를 들어 지금까지 만든 `person` 클래스로 `superson`이라는 인스턴스를 만든다면, `person` 클래스와 `__init__` 함수 내부에서는 다음과 같은 일이 발생할 것입니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age):
...         self.name = name # 인스턴스의 name 속성 = name 에 들어있는 값
...         self.age = age # 인스턴스의 age 속성 = age 에 들어있는 값
>>> superson = person(name="손흥민", age=28) 

################## __init__ 함수 내부에서의 가상의 작용 #######################
__init__(self=superson, name="손흥민", age=28):
    superson.name = "손흥민" # superson.name 에는 "손흥민" 할당
    superson.age = 28 # superson.age 에는 28 할당
###############################################################################

>>> superson.name
'손흥민'
>>> supserson.age
28
```

### 클래스에 메소드 부여하기

일정한 속성을 갖는 클래스를 생성했다면 이제는 메소드, 즉 행동을 정의해볼 차례입니다. 메소드는 역시 클래스 안에 함수로 정의하며, 자신이 원하는 이름으로 함수를 만들어주면 됩니다. 반드시 `self`를 매개변수로 갖는다는 점이 일반적인 함수와 다릅니다.

```{python eval=F}
>>> def 메소드명(self, 인자1, 인자2, ...):
>>>    연산
>>>    return 결과물
```

간단하게 매개변수 없이 `"Hello"` 를 프린트하는 `sayhello` 메소드를 정의해보겠습니다. 메소드는 만들어진 인스턴스 이름 뒤에 점을 짝고 사용하면 됩니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age):
...         self.name = name
...         self.age = age
...     def sayhello(self):
...         print("Hello!")
>>> superson = person(name="손흥민", age=28)
>>> superson.sayhello()
Hello!
```

이번에는 매개변수와 반환을 갖는 `run` 메소드를 정의해보겠습니다. 우선 추가적으로 사람이 1초 동안 달릴 수 있는 거리를 `speed` 라는 속성으로 정의합니다. `__init__` 함수에 `speed`와 관련된 코드를 추가해줍니다. 다음으로 매개변수 `t`를 받아서 `t`초 동안 달린 거리를 반환하는 `run` 메소드를 정의합니다. 인스턴스의 속도는 `self.speed`에 저장될 것이므로, `self.speed * t`를 계산하면 해당 인스턴스가 `t`초 동안 달린 거리를 구할 수 있습니다. 이 결과를 반환값으로 지정합니다.

```{python eval=F}
>>> class person:
...     def __init__(self, name, age, speed):
...         self.name = name
...         self.age = age
...         self.speed = speed # 인스턴스의 속도
...     def sayhello(self):
...         print("Hello!" )
...     def run(self, t):
...         return self.speed * t # 인스턴스의 속도로 t초간 달린 거리
```

이제 평범한 사람과 손흥민 선수가 같이 달려보겠습니다. 손흥민 선수는 1초에 100미터를 뛰는 스피드를 가졌고, 평범한 사람은 1초에 10미터를 뛰는 스피드를 가졌습니다. 사실 성인 남성 중에서도 굉장히 잘 뛰는 편인데, 손흥민 선수가 1000미터를 뛸 동안 평범한 사람은 100미터 밖에 뛰지 못했습니다.

```{python eval=F}
>>> superson = person(name="손흥민", age=28, speed=100)
>>> superson.run(t=10)
1000
>>> normal_guy = person(name="김철수", age=20, speed=10)
>>> normal_guy.run(t=10)
100
```

# 3. 패키지

## 3.1. 모듈

패키지를 다루기 전에, 먼저 모듈이라는 개념에 대해 알아보겠습니다. 모듈은 함수나 변수, 클래스 등을 모아놓은 파일입니다. 즉 모듈은 결국 이미 만들어진 파이썬 코드들입니다. 모듈의 가장 큰 특징은 다른 프로그램에서 손쉽게 재사용할 수 있다는 점입니다. 따라서 다른 사람들이 작성한 코드들을 가져다 쓸 수도 있고, 자신이 작성한 코드를 모듈화해서 보관하였다가 나중에 재사용하는 것도 가능합니다. 일단 간단한 모듈을 만들어보면서 자세히 알아보겠습니다. 모듈은 파이썬 파일 `.py` 로 저장할 것이므로 주피터 노트북이 아닌 다른 에디터에서 코드를 작성하시기 바랍니다.

```{python eval=F}
def add(a,b):
    return a + b
def sub(a,b):
    return a - b
```

위와 같이 덧셈, 뺄셈을 실행하는 간단한 함수 두 개를 정의하고, `mod1.py`라는 이름으로 주피터 노트북이 실행되고 있는 디렉토리에 저장합니다. 이제 파이썬에서 우리가 작성한 `mod1` 모듈을 불러와서 사용할 수 있습니다. 

```{python eval=F}
>>> import mod1
>>> mod1.add(3,4)
7
>>> mod1.sub(5,1)
4
```

`import` 문은 만들어진 모듈을 현재 파이썬 프로그램에 불러오는 구문입니다. `import mod1` 을 실행하면, `mod1` 모듈 안에 들어있는 `add` 함수와 `sub` 함수를 사용할 수 있게 됩니다. 모듈 안에 들어있는 함수나 클래스를 사용하려면 `모듈명.함수명()`, `모듈명.클래스멍()` 과 같이 모듈 이름 뒤에 점을 찍고 함수를 호출하면 됩니다. 즉 `mod1.add(3,4)` 는 `mod1` 모듈 안에 들어있는 `add` 함수를 실행하는 코드입니다.

```{python eval=F}
>>> import mod1 as m
>>> from mod1 import add
```

`import` 는 다양한 방식으로 실행할 수 있습니다. 첫 줄은 `mod1` 모듈을 `m`이라는 별칭(aliasing)로 불러오는 코드입니다. 이 경우 `m.add()`와 같이 자신이 지정한 이름으로 모듈을 사용할 수 있습니니다. 둘째 줄은 모듈로부터 특정한 함수만 불러오는 코드입니다. 때에 따라 모듈 전체를 프로그램에 불러올 필요가 없을 수도 있습니다. 이런 경우에는 `from 모듈명 import 함수/클래스` 와 같이 필요한 함수나 패키지를 특정하여 불러올 수도 있습니다. 이 경우, 모듈명을 생략하고 `add()`를 사용해서 즉시 `mod1` 모듈의 `add` 함수를 사용할 수 있습니다.

## 3.2. 패키지

패키지는 계층적인 구조(디렉토리)로 관리되는 모듈들의 모음입니다. 즉 패키지 역시 사실은 파이썬 코드들의 모음입니다. 다음과 같은 구조로 된 패키지를 살펴보겠습니다. 물론 실제 `pandas` 패키지는 이와 동일하게 생기지는 않았습니다. `pandas` 패키지의 실제 구조는 [판다스 깃허브](https://github.com/pandas-dev/pandas)에서 확인할 수 있습니다.

```
pandas/
    __init__.py
    core/
        __init__.py
        series.py
        frame.py
    io/
        __init__.py
        api.py
        html.py
```

`.py` 확장자가 붙은 파일은 파이썬 모듈이고, 확장자가 없고 /가 붙은 파일은 디렉토리 입니다. 즉 가장 상위에 `pandas` 라는 루트 디렉토리가 존재하고, 이 아래에 `\__init\__.py` 파일과 `core, io` 서브 디렉토리가 존재합니다. 각각의 서브 디렉토리 아래에는 다시 파이썬 모듈들이 들어있습니다. 만약 `padnas/core/series.py` 안에 들어있는 함수나 클래스에 접근하려면 어떻게 해야 할까요? 모듈에서 했던 것과 똑같이 점을 찍어서 하위 디렉토리로 내려가주면 됩니다.

```{python eval=F}
>>> import pandas
>>> pandas.core.series.함수명() # pandas/core/series.py 안에 있는 함수 호출
>>> pandas.core.series.클래스명() # pandas/core/series.py 안에 있는 클래스 호출
```

여기에서 패키지의 계층적인 구조를 이해하는 것이 목표이며, 직접 패키지를 제작해보지는 않을 것입니다. 만약 직접 패키지를 만들어보고 싶다면 [점프 투 파이썬](https://wikidocs.net/1418) 교재를 참고하시기 바랍니다. 모듈과 패키지는 결국 이미 만들어진 파이썬 코드들의 모음이라고 했습니다. 우리는 데이터 분석에 필요한 코드들을 전부 직접 만들어서 사용하지는 않을 것이고, 다른 사람들이 만들어놓은 유용한 도구들을 찾아서 활용하게 될  것입니다. 물론 자신이 직접 유용한 패키지를 개발해서 배포한다면 파이썬 데이터 분석 생태계에 큰 도움이 되겠지만, 지금 당장은 시작하는 입장이므로 만들어진 툴을 잘 활용하는 것에 중점을 두도록 합시다!

## 3.3. 파이썬 패키지 관리자: pip & conda

### pip install

`pip`는 파이썬의 패키지 관리 시스템입니다. `pip`를 통해서 다른 사람들이 개발한 패키지를 다운로드하거나, 이미 설치된 패키지를 업그레이드 혹은 삭제할 수도 있습니다. 다음은 `pip`의 기본적인 패키지 설치/삭제 명령어입니다. `pip` 명령어는 주피터 노트북 셀 혹은 기타 터미널에서 사용할 수 있습니다.

- `pip install 패키지명`
- `pip uninstall 패키지명`

주피터 노트북이나 터미널 창에서 다음 명령어를 실행해보시기 바랍니다. `scikit-learn`은 파이썬의 대표적인 머신러닝 패키지이며, 딥러닝을 제외한 거의 모든 머신러닝에서 사실상의 표준입니다. 설치된 이후에는 import 문을 사용해서 사이킷 런의 선형회귀 클래스와 판다스, 넘파이를 주피터에 불러와보세요.

```{python eval=F}
>>> pip install scikit-learn
>>> from sklearn.linear_model import LinearRegression # 사이킷런의 선형회귀 클래스 불러옴
>>> import pandas as pd # pandas 패키지를 pd라는 별칭으로 불러옴
>>> import numpy as np # numpy 패키지를 np라는 별칭으로 불러옴
```

### conda install

아나콘다에는 `pip install` 과 유사한 `conda install` 이라는 패키지 설치 명령어가 존재합니다. 파이썬으로 개발된 패키지들은 대부분 [PyPI](https://pypi.org/)라는 패키지 저장소를 통해 배포됩니다. `pip install` 명령어는 PyPI를 통해 배포된 패키지들을 다운로드합니다. 반면 `conda install` 명령어는 Anaconda Repository, Anaconda Cloud를 통해 배포된 패키지들을 다운로드합니다. 대부분의 경우 `pip` 를 사용하든 `conda` 를 사용하든 큰 차이가 없습니다. 하지만 `pip`와 `conda`의 인스톨 방식에 차이가 있기 때문에 `pip`로 설치되지 않는 패키지가 `conda`를 통해서는 설치되는 경우도 있습니다. `pip`와 `conda`의 차이를 정확히 이해하기 위해서는 [Understanding Conda and Pip](https://www.anaconda.com/understanding-conda-and-pip/)를 참고하시기 바랍니다.


# 참고자료

- 박응용, [점프 투 파이썬](https://wikidocs.net/book/1)
- Jonathan Helmus, [Understanding Conda and Pip](https://www.anaconda.com/understanding-conda-and-pip/)